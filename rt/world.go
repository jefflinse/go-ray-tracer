package rt

// A World is a collection of objects.
type World struct {
	Light   *PointLight
	Objects []Intersectable
}

// NewWorld creates a new World.
func NewWorld() *World {
	return &World{Objects: make([]Intersectable, 0)}
}

// NewDefaultWorld creates a new World with a light source and two spheres.
func NewDefaultWorld() *World {
	sphere1 := NewSphere()
	sphere1.Material.Color = NewColor(.8, 1, .6)
	sphere1.Material.Diffuse = .7
	sphere1.Material.Specular = .2

	sphere2 := NewSphere()
	sphere2.Transform = NewScaling(.5, .5, .5)

	light := NewPointLight(NewPoint(-10, 10, -10), NewColor(1, 1, 1))

	return &World{
		Light:   light,
		Objects: []Intersectable{sphere1, sphere2},
	}
}

// AddObjects adds one or more objects to the world.
func (w *World) AddObjects(objs ...Intersectable) {
	w.Objects = append(w.Objects, objs...)
}

// ColorAt returns the color computed by intersecting the world with the specified ray.
func (w *World) ColorAt(ray *Ray) Color {
	xs := w.Intersect(ray)
	hit := xs.Hit()
	if hit == nil {
		return NewColor(0, 0, 0)
	}

	info := hit.PrepareComputations(ray)
	return w.ShadeHit(info)
}

// Intersect returns a set of points where a ray intersects objects in the world.
func (w *World) Intersect(ray *Ray) IntersectionSet {
	xs := NewIntersectionSet()
	for _, obj := range w.Objects {
		xs = xs.Join(obj.Intersect(ray))
	}

	return xs
}

// IsShadowed returns true if the specified point is in a shadow.
func (w *World) IsShadowed(point Tuple) bool {
	v := w.Light.Position.Subtract(point)
	distance := v.Magnitude()
	direction := v.Normalize()

	ray := NewRay(point, direction)
	intersections := w.Intersect(ray)

	hit := intersections.Hit()
	return hit != nil && hit.T < distance
}

// ShadeHit returns the color generated by lighting based on the provided intersection info.
func (w *World) ShadeHit(info *IntersectionInfo) Color {
	isShadowed := w.IsShadowed(info.OverPoint)
	return info.Object.GetMaterial().Lighting(w.Light, info.Point, info.EyeV, info.NormalV, isShadowed)
}
